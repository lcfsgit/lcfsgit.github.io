<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>hexo+typra+picgo+gitee搭建博客写作环境</title>
      <link href="/2023/08/21/hexo-typra-picgo-gitee%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E5%86%99%E4%BD%9C%E7%8E%AF%E5%A2%83/"/>
      <url>/2023/08/21/hexo-typra-picgo-gitee%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E5%86%99%E4%BD%9C%E7%8E%AF%E5%A2%83/</url>
      
        <content type="html"><![CDATA[<p>博客使用hexo，部署在github page，Typora支持markdown非常棒，但是图片之类的无法直接上传到云端，因为它的图片是本地的，这几天看到网上有介绍Typora设置免费的图床（gitee），而且图片粘贴上去，直接自动上传到图床生成链接，这样将<code>md</code>文件发给别人，再也不用担心图片无法正常显示的问题了。设置好之后，写一篇教程，记录一下。</p><h4 id="安装下载PicGo"><a href="#安装下载PicGo" class="headerlink" title="安装下载PicGo"></a>安装下载PicGo</h4><p>山东大学镜像站 <a href="https://mirrors.sdu.edu.cn/github-release/Molunerfinn_PicGo/%EF%BC%8C%E9%80%89%E6%8B%A9%E6%9C%80%E6%96%B0%E7%89%88%E6%9C%AC%E4%B8%8B%E8%BD%BD">https://mirrors.sdu.edu.cn/github-release/Molunerfinn_PicGo/，选择最新版本下载</a></p><p><img src="https://gitee.com/lcfsgitee/image-library/raw/master/image-20230821151540523.png" alt="image-20230821151540523"></p><h4 id="新建gitee仓库-生成令牌"><a href="#新建gitee仓库-生成令牌" class="headerlink" title="新建gitee仓库-生成令牌"></a>新建gitee仓库-生成令牌</h4><p>新仓库要初始化readme！！！</p><p><img src="https://gitee.com/lcfsgitee/image-library/raw/master/image-20230821151620466.png" alt="image-20230821151620466"></p><h5 id="在PicGo设置图床参数"><a href="#在PicGo设置图床参数" class="headerlink" title="在PicGo设置图床参数"></a>在PicGo设置图床参数</h5><p><code>repo：用户名/网址仓库名</code>,并设置为默认图库</p><p><img src="https://gitee.com/lcfsgitee/image-library/raw/master/image-20230821151639633.png" alt="image-20230821151639633"></p><h4 id="设置typra"><a href="#设置typra" class="headerlink" title="设置typra"></a>设置typra</h4><h4 id=""><a href="#" class="headerlink" title=""></a><img src="https://gitee.com/lcfsgitee/image-library/raw/master/image-20230821151701055.png" alt="image-20230821151701055"></h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">hexo new post <span class="string">&quot;xxx&quot;</span></span><br><span class="line">hexo c</span><br><span class="line">hexo g</span><br><span class="line">hexo s</span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 博客搭建 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo gitee PicGo Typra </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>动态监听搜索实现</title>
      <link href="/2023/08/21/%E5%8A%A8%E6%80%81%E7%9B%91%E5%90%AC%E6%90%9C%E7%B4%A2%E5%AE%9E%E7%8E%B0/"/>
      <url>/2023/08/21/%E5%8A%A8%E6%80%81%E7%9B%91%E5%90%AC%E6%90%9C%E7%B4%A2%E5%AE%9E%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<h3 id="需求是怎样的"><a href="#需求是怎样的" class="headerlink" title="需求是怎样的"></a>需求是怎样的</h3><p>因为数据条数过多，用户要求新增搜索功能</p><p><img src="https://gitee.com/lcfsgitee/image-library/raw/master/image-20230821151723985.png" alt="image-20230821151723985"></p><h3 id="实际如何做"><a href="#实际如何做" class="headerlink" title="实际如何做"></a>实际如何做</h3><p>面板头部头部空间有限，再加之考虑美观性，决定通过<strong>动态监听搜索框</strong>内所输入的数据，展示匹配结果。因为监听变量位于对象内，故采用<strong>深度监听</strong>。</p><h4 id="两种监听方式"><a href="#两种监听方式" class="headerlink" title="两种监听方式"></a>两种监听方式</h4><h5 id="普通监听"><a href="#普通监听" class="headerlink" title="普通监听"></a>普通监听</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">&lt;div&gt;&lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">data()&#123;</span><br><span class="line">variable:null,</span><br><span class="line">&#125;,</span><br><span class="line">watch:&#123;</span><br><span class="line">// 此处监听variable变量，当期有变化时执行</span><br><span class="line">variable(item1,item2)&#123;</span><br><span class="line">// item1为新值，item2为旧值</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h5 id="深度监听（变量在对象内）"><a href="#深度监听（变量在对象内）" class="headerlink" title="深度监听（变量在对象内）"></a>深度监听（变量在对象内）</h5><h6 id="一个变量"><a href="#一个变量" class="headerlink" title="一个变量"></a>一个变量</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">&lt;div&gt;&lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">data()&#123;</span><br><span class="line">obj:&#123;</span><br><span class="line">a:&#x27;&#x27;</span><br><span class="line">&#125;,</span><br><span class="line">&#125;,</span><br><span class="line">watch:&#123;</span><br><span class="line">// 此处监听obj属性a值变量</span><br><span class="line">&#x27;obj.a&#x27;(item1,item2)&#123;</span><br><span class="line">// item1为新值，item2为旧值</span><br><span class="line">&#125;,</span><br><span class="line">deep:true</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h6 id="多个变量"><a href="#多个变量" class="headerlink" title="多个变量"></a>多个变量</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">&lt;div&gt;&lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">data()&#123;</span><br><span class="line">obj:&#123;</span><br><span class="line">a:&#x27;&#x27;,</span><br><span class="line">b:&#x27;&#x27;,</span><br><span class="line">c:&#x27;&#x27;</span><br><span class="line">&#125;,</span><br><span class="line">&#125;,</span><br><span class="line">watch:&#123;</span><br><span class="line">obj:&#123;</span><br><span class="line">// 此处监听obj属性a值变量</span><br><span class="line">handler(item1,item2)&#123;</span><br><span class="line">// item1为新值，item2为旧值</span><br><span class="line">&#125;,</span><br><span class="line">deep:true </span><br><span class="line">// 对象中对象属性变化监测需要使用deep:true，多少层内产生变化都可以监测到</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h4 id="实际代码"><a href="#实际代码" class="headerlink" title="实际代码"></a>实际代码</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&lt;/template&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="title function_">data</span>(<span class="params"></span>)&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="attr">overviewForm</span>:&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"> <span class="attr">name</span>:<span class="string">&#x27;&#x27;</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">&#125;,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">&#125;,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="attr">watch</span>:&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">                <span class="string">&#x27;overviewForm.name&#x27;</span> (newName) &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">                    <span class="variable language_">this</span>.<span class="title function_">fetchOverviewData</span>(newName);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">                &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">            &#125;,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        methods：&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">         <span class="comment">//获取车间信息</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">                <span class="title function_">fetchWorkShopData</span>(<span class="params">param</span>)&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">                    <span class="title function_">axios</span>(&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">                        <span class="attr">headers</span>: &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">                            <span class="string">&quot;Access-Control-Allow-Origin&quot;</span>:<span class="string">&quot;*&quot;</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">                        &#125;,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">                        <span class="attr">method</span>: <span class="string">&#x27;post&#x27;</span>,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">                        <span class="attr">url</span>: <span class="title class_">HTTPUrl</span>+<span class="string">&#x27;reason/queryWorkShopList&#x27;</span>,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">                        <span class="attr">data</span>: &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">                            <span class="attr">company_id</span>: param,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">                        &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">                    &#125;).<span class="title function_">then</span>(<span class="function"><span class="params">res</span>=&gt;</span>&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">                        <span class="keyword">if</span>(res.<span class="property">status</span>===<span class="number">200</span>)&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">                            <span class="variable language_">console</span>.<span class="title function_">log</span>(res.<span class="property">data</span>)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">                            <span class="variable language_">this</span>.<span class="property">workshopList</span>=res.<span class="property">data</span>.<span class="property">data</span>;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">                            <span class="comment">// this.alarmTypeList=res.data.data.alarmTypeList;</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">                        &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">                    &#125;)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">                &#125;,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">&#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="最终实现结果"><a href="#最终实现结果" class="headerlink" title="最终实现结果"></a>最终实现结果</h4><p><img src="https://gitee.com/lcfsgitee/image-library/raw/master/image-20230821151741296.png" alt="image-20230821151741296"></p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue element 深度监听 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>sql条件查询</title>
      <link href="/2023/08/20/sql%E6%9D%A1%E4%BB%B6%E6%9F%A5%E8%AF%A2/"/>
      <url>/2023/08/20/sql%E6%9D%A1%E4%BB%B6%E6%9F%A5%E8%AF%A2/</url>
      
        <content type="html"><![CDATA[<h4 id="sql条件查询"><a href="#sql条件查询" class="headerlink" title="sql条件查询-"></a>sql条件查询-</h4><h5 id="使用like-实现模糊查询，子查询"><a href="#使用like-实现模糊查询，子查询" class="headerlink" title="使用like,实现模糊查询，子查询"></a>使用like,<strong>实现模糊查询</strong>，子查询</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">            <span class="built_in">MAX</span>( ctime ) <span class="keyword">AS</span> max_ctime</span><br><span class="line">        <span class="keyword">FROM</span></span><br><span class="line">            ( <span class="keyword">SELECT</span> ctime <span class="keyword">FROM</span> alarm_monitor <span class="keyword">WHERE</span> alarm_status <span class="operator">=</span> <span class="string">&#x27;true&#x27;</span> <span class="keyword">AND</span> is_under <span class="keyword">like</span> <span class="string">&#x27;%0&#x27;</span> ) <span class="keyword">as</span> a</span><br></pre></td></tr></table></figure><h5 id="使用自定义值，默认查询所有"><a href="#使用自定义值，默认查询所有" class="headerlink" title="使用自定义值，默认查询所有"></a>使用自定义值，默认查询所有</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span> <span class="variable">@pos</span><span class="operator">=</span>&quot;&quot;</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> (name<span class="operator">=</span><span class="variable">@pos</span> <span class="keyword">or</span> <span class="variable">@pos</span><span class="operator">=</span>&quot;&quot;)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MYSQL 条件查询 子查询 模糊查询 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于mysql大小写敏感问题</title>
      <link href="/2023/08/20/%E5%85%B3%E4%BA%8Emysql%E5%A4%A7%E5%B0%8F%E5%86%99%E6%95%8F%E6%84%9F%E9%97%AE%E9%A2%98/"/>
      <url>/2023/08/20/%E5%85%B3%E4%BA%8Emysql%E5%A4%A7%E5%B0%8F%E5%86%99%E6%95%8F%E6%84%9F%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h4 id="1-决定大小写是否敏感的参数"><a href="#1-决定大小写是否敏感的参数" class="headerlink" title="1.决定大小写是否敏感的参数"></a>1.决定大小写是否敏感的参数</h4><p>在 <a href="https://cloud.tencent.com/product/cdb?from=10680">MySQL</a> 中，数据库与 data 目录中的目录相对应。数据库中的每个表都对应于数据库目录中的至少一个文件（可能是多个文件，具体取决于存储引擎）。因此，操作系统的大小写是否敏感决定了数据库大小写是否敏感，而 Windows 系统是对大小写不敏感的，Linux 系统对大小写敏感。</p><p>默认情况下，库表名在 Windows 系统下是不区分大小写的，而在 Linux 系统下是区分大小写的。列名，索引名，存储过程、函数及事件名称在任何操作系统下都不区分大小写，列别名也不区分大小写。</p><p>除此之外，MySQL 还提供了 lower_case_table_names 系统变量，该参数会影响表和数据库名称在磁盘上的存储方式以及在 MySQL 中的使用方式，在 Linux 系统，该参数默认为 0 ，在 Windows 系统，默认值为 1 ，在 macOS 系统，默认值为 2 。下面再来看下各个值的具体含义：</p><table><thead><tr><th align="left">Value</th><th align="left">Meaning</th></tr></thead><tbody><tr><td align="left">0</td><td align="left">库表名以创建语句中指定的字母大小写存储在磁盘上，名称比较区分大小写。</td></tr><tr><td align="left">1</td><td align="left">库表名以小写形式存储在磁盘上，名称比较不区分大小写。MySQL 在存储和查找时将所有表名转换为小写。此行为也适用于数据库名称和表别名。</td></tr><tr><td align="left">2</td><td align="left">库表名以创建语句中指定的字母大小写存储在磁盘上，但是 MySQL 在查找时将它们转换为小写。名称比较不区分大小写。</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>每日总结-8.10</title>
      <link href="/2023/08/19/%E6%AF%8F%E6%97%A5%E6%80%BB%E7%BB%93-8-10/"/>
      <url>/2023/08/19/%E6%AF%8F%E6%97%A5%E6%80%BB%E7%BB%93-8-10/</url>
      
        <content type="html"><![CDATA[<h5 id="出现的问题"><a href="#出现的问题" class="headerlink" title="出现的问题"></a>出现的问题</h5><ol><li><p>使用springboot自动注入，没有引用接口，而是直接引用的类，导致在类名修改的时候，要寻找到引用类名的地方，在修改类名</p></li><li><p>不同数据库表的pojo类复用，导致后期在数据库表的数据相差较大时，还需再次定义对应的pojo类，此时大量的逻辑都是针对之前的pojo类操作，导致代码改动较大</p></li><li><p>在编写dao层时，对于方法的通用性考虑不足，<strong>不符合开闭原则</strong>，例如在传参时，固定传参某个对象</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;PatrolArea&gt; queryFirstAreaByAreaId(PatrolDevice patrolDevice)</span><br></pre></td></tr></table></figure><p>造成如果此时有另一对象同样含有areaid，那么需要再写一个方法去适应这种变化，</p><p><strong>改进方案</strong></p><ol><li><p>将传参类型变为基础类型</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;PatrolArea&gt; queryFirstAreaByAreaId(String id)</span><br></pre></td></tr></table></figure></li><li><p>或者将传参改为接口，只要实现接口，都可以作为参数被传入，如果实现类中没有查询条件，也就是<strong>areaid</strong>，那么查询就会出错，此时需要在接口中实现赋值方法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class PatrolArea implements interface&#123;</span><br><span class="line">   String areaId=‘’；</span><br><span class="line">   void setAreaId(String id);</span><br><span class="line">&#125;</span><br><span class="line">List&lt;PatrolArea&gt; queryFirstAreaByAreaId(interface param)</span><br></pre></td></tr></table></figure></li></ol></li></ol><h5 id="获得的经验"><a href="#获得的经验" class="headerlink" title="获得的经验"></a>获得的经验</h5><ol><li><p>使用hutool自定义线程池，并提交任务以及判断，任务结束时返回响应的方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ExecutorService</span> <span class="variable">executor</span> <span class="operator">=</span> ExecutorBuilder.create()</span><br><span class="line">                .setCorePoolSize(<span class="number">3</span>)</span><br><span class="line">                .setMaxPoolSize(<span class="number">6</span>)</span><br><span class="line">                .setWorkQueue(<span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;&gt;(<span class="number">100</span>))</span><br><span class="line">                .build();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Future task1=executor.submit(<span class="keyword">new</span> <span class="title class_">InsertRecordTask</span>());</span><br><span class="line">            Future task2=executor.submit(<span class="keyword">new</span> <span class="title class_">InsertItemTask</span>());</span><br><span class="line">            Future task3=executor.submit(<span class="keyword">new</span> <span class="title class_">InsertImageTask</span>());</span><br><span class="line">            <span class="keyword">if</span>(task1.get()==<span class="literal">null</span> &amp;&amp; task2.get() == <span class="literal">null</span> &amp;&amp; task3.get() ==<span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ResponseDTO</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            executor.shutdown();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ResponseDTO</span>(<span class="string">&quot;线程执行异常&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ResponseDTO</span>(<span class="string">&quot;线程执行任务失败&quot;</span>);</span><br><span class="line">        </span><br></pre></td></tr></table></figure><p>java提交线程池的两种方式：<strong>execute</strong>和<strong>submit</strong></p><ol><li><p>execute用于提交无返回值的任务，也就是某个class继承了Runnable接口并且重写了run方法的任务。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">static class ThreadTask implements Runnable&#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            System.out.println(&quot;正在执行多线程任务......&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> executor.submit(new Runnable() &#123;</span><br><span class="line">                @Override</span><br><span class="line">                public void run() &#123;</span><br><span class="line">                    </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br></pre></td></tr></table></figure></li><li><p>submit用于提交有返回值的任务，也就是继承了Callable接口并且重写了call方法的任务，最好指定返回类型。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">static class CallableTask implements Callable&#123;</span><br><span class="line">        @Override</span><br><span class="line">        public String call() throws Exception &#123;</span><br><span class="line">            return &quot;正在有返回值的多线程任务......&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ol></li><li><p>使用hutool文件工具，接受上传的图片，并保存到本地用ngnix映射的目录方法</p></li><li><p>在对项目运行较重要的逻辑部分，要习惯抛出异常，最后由路由捕捉，统一返回到前端，避免大量的判断逻辑</p></li><li><p>解析前端较复杂的数据时，可针对数据格式指定对应的dto类，使用注解自动解析（@resquestBody注解只能解析一次）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class PatrolRectifiedDTO &#123;</span><br><span class="line"></span><br><span class="line">    public List&lt;PatrolImage&gt; rectifiedImages;</span><br><span class="line"></span><br><span class="line">    public PatrolRecord rectifiedResult;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      <categories>
          
          <category> 每日总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> springboot hutool </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>接口改造多线程</title>
      <link href="/2023/08/19/%E6%8E%A5%E5%8F%A3%E6%94%B9%E9%80%A0%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
      <url>/2023/08/19/%E6%8E%A5%E5%8F%A3%E6%94%B9%E9%80%A0%E5%A4%9A%E7%BA%BF%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h5 id="采用共享变量＋Callable的方式"><a href="#采用共享变量＋Callable的方式" class="headerlink" title="采用共享变量＋Callable的方式"></a>采用共享变量＋Callable的方式</h5><p>需求：将同步代码改成多线程</p><p>原始同步代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">  JSONObject resultJson=<span class="keyword">new</span> <span class="title class_">JSONObject</span>();</span><br><span class="line"><span class="comment">//查询该用户是否存在该任务</span></span><br><span class="line">   patrolDevice.setHead_people_id_number(userService.getUserDetailAndCheckIdNumber(token));</span><br><span class="line">        List&lt;PatrolDevice&gt; results=patrolDeviceDao.queryDeviceByObjectNoPagination(patrolDevice);</span><br><span class="line">        <span class="keyword">if</span>(results.isEmpty() || results.size()&gt;<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">MissingArgumentException</span>(<span class="string">&quot;本设备不属于当前登录人员的巡检任务&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        PatrolDevice resultDevice=results.get(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span>(resultDevice.getDevice_type()==<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">MissingArgumentException</span>(<span class="string">&quot;获取巡检任务类型异常，获取检查项失败，请完善巡检任务基础信息&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">long</span> interval= TimeUtil.getExpireIntervalByExpireTime(resultDevice.getExpiry_time());</span><br><span class="line">        resultDevice.setExpire_interval(interval);</span><br><span class="line">        List&lt;PatrolCheckItem&gt;resultItems=patrolCheckItemDao.queryCheckItemByTypeName(<span class="keyword">new</span> <span class="title class_">PatrolDeviceType</span>(resultDevice.getDevice_type()));</span><br><span class="line">        <span class="type">AppUser</span> <span class="variable">resultUser</span> <span class="operator">=</span> userService.getUserDetail(token);</span><br><span class="line"></span><br><span class="line">        resultJson.put(<span class="string">&quot;checkItem&quot;</span>,resultItems);</span><br><span class="line">        resultJson.put(<span class="string">&quot;taskDetail&quot;</span>, resultDevice);</span><br><span class="line">        resultJson.put(<span class="string">&quot;userDetail&quot;</span>, resultUser);</span><br><span class="line">        <span class="keyword">return</span> resultJson;</span><br></pre></td></tr></table></figure><p>改进成多线程方式</p><p>首先使用<strong>ExecutorService</strong>线程池固定生成三个线程：</p><ul><li><p>身份验证线程</p></li><li><p>用户详情查询线程</p></li><li><p>任务详情查询功能</p></li></ul><p>但是，后两种线程需要第一个线程的执行结果，且三个线程需要共同将执行结果<strong>put</strong>到结果json类中，<strong>期间用户详情查询线程需要根据身份验证线程的返回结果作补充</strong>。</p><p>采用<strong>Future</strong>父类接受执行结果，利用<strong>get</strong>（）函数阻塞，实现在身份验证线程执行完后，在异步执行后两种线程。自定义有参构造函数，实现参数的接续传递和共享。</p><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> JSONObject <span class="title function_">queryCheckTaskDetailByUserToken</span><span class="params">(String token, PatrolDevice patrolDevice)</span> <span class="keyword">throws</span> MissingArgumentException &#123;</span><br><span class="line">        JSONObject resultJson=<span class="keyword">new</span> <span class="title class_">JSONObject</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">executorService</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Future&lt;PatrolDevice&gt; futureIdentifier = executorService.submit(<span class="keyword">new</span> <span class="title class_">IdentifierTask</span>(patrolDevice,token));</span><br><span class="line">            PatrolDevice resultDevice=futureIdentifier.get();</span><br><span class="line">            Future&lt;List&lt;PatrolCheckItem&gt;&gt; futurePatrolTask = executorService.submit(<span class="keyword">new</span> <span class="title class_">FetchPatrolTask</span>(resultDevice,resultJson));</span><br><span class="line">            Future&lt;AppUser&gt; futureUser = executorService.submit(<span class="keyword">new</span> <span class="title class_">FetchUserDetail</span>(token,resultJson));</span><br><span class="line">            <span class="keyword">if</span>(futurePatrolTask.get()==<span class="literal">null</span> &amp;&amp; futureUser.get()==<span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> resultJson;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            executorService.shutdown();</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">MissingArgumentException</span>(e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> resultJson;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//线程任务类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">IdentifierTask</span> <span class="keyword">implements</span> <span class="title class_">Callable</span>&lt;PatrolDevice&gt; &#123;</span><br><span class="line">        <span class="keyword">public</span> PatrolDevice patrolDevice;</span><br><span class="line">        <span class="keyword">public</span> String token;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">IdentifierTask</span><span class="params">(PatrolDevice patrolDevice, String token)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.patrolDevice = patrolDevice;</span><br><span class="line">            <span class="built_in">this</span>.token = token;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> PatrolDevice <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">            patrolDevice.setHead_people_id_number(userService.getUserDetailAndCheckIdNumber(token));</span><br><span class="line">            List&lt;PatrolDevice&gt; results=patrolDeviceDao.queryDeviceByObjectNoPagination(patrolDevice);</span><br><span class="line">            <span class="keyword">if</span>(results.isEmpty() || results.size()&gt;<span class="number">1</span>)&#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">MissingArgumentException</span>(<span class="string">&quot;本设备不属于当前登录人员的巡检任务&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> results.get(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">FetchPatrolTask</span> <span class="keyword">implements</span> <span class="title class_">Callable</span>&lt;List&lt;PatrolCheckItem&gt;&gt;&#123;</span><br><span class="line">        <span class="keyword">public</span> PatrolDevice  resultDevice;</span><br><span class="line">        <span class="keyword">public</span> JSONObject resultJson;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">FetchPatrolTask</span><span class="params">(PatrolDevice resultDevice, JSONObject resultJson)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.resultDevice = resultDevice;</span><br><span class="line">            <span class="built_in">this</span>.resultJson = resultJson;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> List&lt;PatrolCheckItem&gt; <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">            <span class="keyword">if</span>(resultDevice.getDevice_type()==<span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">MissingArgumentException</span>(<span class="string">&quot;获取巡检任务类型异常，获取检查项失败，请完善巡检任务基础信息&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">long</span> interval= TimeUtil.getExpireIntervalByExpireTime(resultDevice.getExpiry_time());</span><br><span class="line">            resultDevice.setExpire_interval(interval);</span><br><span class="line">            List&lt;PatrolCheckItem&gt;resultItems=patrolCheckItemDao.queryCheckItemByTypeName(<span class="keyword">new</span> <span class="title class_">PatrolDeviceType</span>(resultDevice.getDevice_type()));</span><br><span class="line">            resultJson.put(<span class="string">&quot;checkItem&quot;</span>,resultItems);</span><br><span class="line">            resultJson.put(<span class="string">&quot;taskDetail&quot;</span>, resultDevice);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">FetchUserDetail</span> <span class="keyword">implements</span> <span class="title class_">Callable</span>&lt;AppUser&gt; &#123;</span><br><span class="line">        <span class="keyword">public</span> String token;</span><br><span class="line">        <span class="keyword">public</span> JSONObject resultJson;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">FetchUserDetail</span><span class="params">(String token, JSONObject resultJson)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.token = token;</span><br><span class="line">            <span class="built_in">this</span>.resultJson = resultJson;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> AppUser <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">            <span class="type">AppUser</span> <span class="variable">resultUser</span> <span class="operator">=</span> userService.getUserDetail(token);</span><br><span class="line">            resultJson.put(<span class="string">&quot;userDetail&quot;</span>, resultUser);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">        </span><br></pre></td></tr></table></figure><h5 id="性能测试"><a href="#性能测试" class="headerlink" title="性能测试"></a>性能测试</h5><p>单线程<strong>10000</strong>次请求的压力测试，设定100ms的响应时间为标准：</p><table><thead><tr><th align="center"></th><th align="center">通过</th><th align="center">未通过</th></tr></thead><tbody><tr><td align="center">改进前</td><td align="center">9106次</td><td align="center">896次</td></tr><tr><td align="center">改进后</td><td align="center">9254</td><td align="center">746</td></tr></tbody></table><p>单线程100次压力测试，设定30ms的响应时间为标准</p><table><thead><tr><th align="center"></th><th align="center">通过</th><th align="center">未通过</th></tr></thead><tbody><tr><td align="center">改进前</td><td align="center">53</td><td align="center">47</td></tr><tr><td align="center">改进后</td><td align="center">58</td><td align="center">42</td></tr></tbody></table><p>单线程100次压力测试，设定10ms的响应时间为标准</p><table><thead><tr><th align="center"></th><th align="center">通过</th><th align="center">未通过</th></tr></thead><tbody><tr><td align="center">改进前</td><td align="center">0</td><td align="center">100</td></tr><tr><td align="center">改进后</td><td align="center">2</td><td align="center">98</td></tr></tbody></table><p>测试结果由于现场网络情况较差且不稳定原因，会有偏差，但是综合来看，改进后响应速度还是有提升，特别是在压力较大的情况下，提升较为明显。</p>]]></content>
      
      
      <categories>
          
          <category> 调优记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>分布式锁</title>
      <link href="/2023/08/19/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/"/>
      <url>/2023/08/19/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/</url>
      
        <content type="html"><![CDATA[<h4 id="线程锁"><a href="#线程锁" class="headerlink" title="线程锁"></a>线程锁</h4><p>给方法、代码块加锁，某个方法或代码使用锁，在同一时刻仅有一个线程执行该方法或该代码段。线程锁只在同一JVM中有效果，因为线程锁的实现在根本上是依靠线程之间共享内存实现的，比如Synchronized、Lock等</p><h4 id="进程锁"><a href="#进程锁" class="headerlink" title="进程锁"></a>进程锁</h4><p>控制同一个系统中多个线程访问同一个共享资源，因为程序的独立性，各个进程无法控制其他进程对资源的访问，可以利用操作系统的信号量机制</p><h4 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h4><p>多个进程不在同一个系统中，使用分布式锁控制多个进程对同一资源的访问</p><h5 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h5><ul><li><strong>互斥性</strong>：任意时刻，只能有一个客户端可以获取锁</li><li><strong>安全性</strong>::  锁只能被持有该锁的客户端删除，不能由其它客户端删除</li><li><strong>死锁</strong>: 获取锁的客户端因为某些原因（如down机等）而未能释放锁，其它客户端再也无法获取到该锁。</li><li><strong>容错</strong>：当部分节点（redis节点等）down机时，客户端仍然能够获取锁和释放锁</li></ul><h5 id="实现分布式锁的三种方式"><a href="#实现分布式锁的三种方式" class="headerlink" title="实现分布式锁的三种方式"></a>实现分布式锁的三种方式</h5><ul><li>基于缓存（Redis等）实现分布式锁； </li><li>基于数据库实现分布式锁； </li><li>基于Zookeeper实现分布式锁；</li></ul><h5 id="基于Redis的分布式锁"><a href="#基于Redis的分布式锁" class="headerlink" title="基于Redis的分布式锁"></a>基于Redis的分布式锁</h5><h6 id="利用SETNX和SETEX"><a href="#利用SETNX和SETEX" class="headerlink" title="利用SETNX和SETEX"></a>利用SETNX和SETEX</h6><p>使用key-value的方式，以数据的某个属性作为键，给改代码块或者对象加锁。在进程初次使用改数据时，会先检查键是不是已经被创建（被锁），否则创建键（加锁）。发现数据被锁后，会不断的在设置超时时间的范围内循环请求该数据，直到超出超时时间。</p><p><strong>缺点：</strong></p><ol><li>高并发的情况下，如果两个线程同时进入循环，可能导致加锁失败。</li><li>SETNX 是一个耗时操作，因为它需要判断 Key 是否存在，因为会存在性能问题。</li></ol><p>官方推荐使用Redlock实现分布式锁，更加可靠；</p><h5 id="基于数据库表的分布式锁"><a href="#基于数据库表的分布式锁" class="headerlink" title="基于数据库表的分布式锁"></a>基于数据库表的分布式锁</h5><h6 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h6><p>乐观锁认为不会有人同时修改数据，即不会上锁，只有在最终更新数据的时候判断一下再次期间别人有无修改数据，如果有修改，则放弃操作，否则执行操作。</p><p><strong>实现原理：</strong></p><p>一般通过version来实现，也就是在数据库表创建一个 version 字段，每次更新成功，则 version+1，读取数据时，我们将 version 字段一并读出，每次更新时将会对版本号进行比较，如果一致则执行此操作，否则更新失败！</p><h6 id="悲观锁"><a href="#悲观锁" class="headerlink" title="悲观锁"></a>悲观锁</h6><p>基于InnoDB引擎，使用数据库的排它锁实现，在操作数据时直接把数据锁住，直到操作完成再释放锁，上锁期间其他人不能修改数据。</p><p><strong>排它锁原理：</strong></p><p><strong>for update</strong>是一种行级锁，又叫排它锁。一旦用户对某个行施加了行级加锁，则该用户可以查询也可以更新被加锁的数据行，其它用户只能查询但不能更新被加锁的数据行。行锁永远是<strong>独占方式</strong>锁。只有当出现如下的条件时，才会释放锁：<strong>1、执行提交（COMMIT）语句；2、退出数据库（LOG　OFF）；3、程序停止运行。</strong></p><p><strong>实现原理：</strong></p><p>创建一个数据表用于记录分布式锁（可以区分业务模块），然后在需要使用分布式锁的地方，通过select……for update获取对应业务模块的锁记录，如果获取成功，该记录行被锁定，其他线程将只能等待，当该线程执行结束后，就会释放锁，其他线程就可以获取锁并继续执行</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">lock</span><span class="params">()</span>&#123;</span><br><span class="line">    connection.setAutoCommit(<span class="literal">false</span>)</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            result = select * from methodLock where method_name=xxx <span class="keyword">for</span> update;</span><br><span class="line">            <span class="keyword">if</span>(result==<span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        sleep(<span class="number">1000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过以下方法解锁：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public <span class="keyword">void</span> <span class="title function_">unlock</span>(<span class="params"></span>)&#123;</span><br><span class="line">    connection.<span class="title function_">commit</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="基于Zookeeper实现分布式锁"><a href="#基于Zookeeper实现分布式锁" class="headerlink" title="基于Zookeeper实现分布式锁"></a>基于Zookeeper实现分布式锁</h5><p>实现原理为：</p><ol><li>建立一个节点，假如名为 lock 。节点类型为持久节点（Persistent）</li><li>每当进程需要访问共享资源时，会调用分布式锁的 lock() 或 tryLock() 方法获得锁，这个时候会在第一步创建的 lock 节点下建立相应的顺序子节点，节点类型为临时顺序节点（<code>EPHEMERAL_SEQUENTIAL</code>），通过组成特定的名字 name+lock+顺序号。</li><li>在建立子节点后，对 lock 下面的所有以 name 开头的子节点进行排序，判断刚刚建立的子节点顺序号是否是最小的节点，假如是最小节点，则获得该锁对资源进行访问。</li><li>假如不是该节点，就获得该节点的上一顺序节点，并监测该节点是否存在注册监听事件（上一个节点是不是被删除）。同时在这里阻塞。等待监听事件的发生，获得锁控制权。前一个Znode删除的时候，会触发Znode事件，当前节点能监听到删除事件，就是轮到了自己占有锁的时候。第一个通知第二个、第二个通知第三个，击鼓传花似的依次向后，只要上一个节点被删除了，就进行再一次判断，看看自己是不是序号最小的那个节点，如果是，自己就获得锁。</li><li>当调用完共享资源后，调用 unlock() 方法，关闭 ZooKeeper，进而可以引发监听事件，释放该锁。</li></ol>]]></content>
      
      
      <categories>
          
          <category> java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分布式锁 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>多线程导出excel</title>
      <link href="/2023/08/19/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%AF%BC%E5%87%BAexcel/"/>
      <url>/2023/08/19/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%AF%BC%E5%87%BAexcel/</url>
      
        <content type="html"><![CDATA[<h4 id="线程池的5种状态"><a href="#线程池的5种状态" class="headerlink" title="线程池的5种状态"></a>线程池的5种状态</h4><h5 id="状态分类"><a href="#状态分类" class="headerlink" title="状态分类"></a>状态分类</h5><h6 id="RUNNING"><a href="#RUNNING" class="headerlink" title="RUNNING"></a>RUNNING</h6><p>线程池处在 RUNNING 状态时，能够接收新任务，以及对已添加的任务进行处理。该状态是线程池的初始状态，线程池一旦被创建，就处于 RUNNING 状态</p><h6 id="SHUTDOWN"><a href="#SHUTDOWN" class="headerlink" title="SHUTDOWN"></a>SHUTDOWN</h6><p>线程池处于 SHUTDOWN 状态时，不接收新任务，但能处理等待队列中的任务。线程池在 RUNNING 状态下，调用 shutdown() 方法，会变成 SHUTDOWN 状态。</p><h6 id="STOP"><a href="#STOP" class="headerlink" title="STOP"></a>STOP</h6><p>线程池处于 STOP 状态时，不接收新任务，不再处理等待队列中的任务，并且会中断正在处理的任务线程池在 RUNNING 状态下，调用 shutdownNow() 方法，变为 STOP 状态</p><h6 id="TIDYING"><a href="#TIDYING" class="headerlink" title="TIDYING"></a>TIDYING</h6><p>所有的任务都销毁了，工作线程数量为0，线程池的状态在转换为 TIDYING 状态时，会执行钩子方法 terminated()线程池在 SHUTDOWN 状态时，阻塞队列为空并且线程池中执行的任务也为空时，就会由 SHUTDOWN 状态变为 TIDYING 状态；线程池在 STOP 状态时，线程池中执行的任务为空时，就会由 STOP 状态变为 TIDYING 。</p><h6 id="TERMINATED"><a href="#TERMINATED" class="headerlink" title="TERMINATED"></a>TERMINATED</h6><p>terminated() 方法执行之后，线程池彻底终止，就变成 TERMINATED 状态。</p><p><img src="D:\Typora\pictrue\b2d68600f0dbea2606b1077ff12a04d3.png" alt="b2d68600f0dbea2606b1077ff12a04d3.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> XSSFWorkbook <span class="title function_">createExcel</span><span class="params">(List&lt;DataHistory&gt; list, ArrayList&lt;String&gt; titles)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">// 创建工作薄对象</span></span><br><span class="line">        <span class="type">XSSFWorkbook</span> <span class="variable">workbook</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">XSSFWorkbook</span>();</span><br><span class="line">        <span class="comment">// 创建sheet页</span></span><br><span class="line">        <span class="type">XSSFSheet</span> <span class="variable">sheet</span> <span class="operator">=</span> workbook.createSheet();</span><br><span class="line">        <span class="comment">// 自动换行</span></span><br><span class="line">        <span class="type">XSSFCellStyle</span> <span class="variable">style</span> <span class="operator">=</span> workbook.createCellStyle();</span><br><span class="line">        style.setWrapText(<span class="literal">true</span>);</span><br><span class="line">        <span class="comment">// 创建sheet页的行  表头</span></span><br><span class="line">        <span class="type">XSSFRow</span> <span class="variable">row</span> <span class="operator">=</span> sheet.createRow(<span class="number">0</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">columnIndex</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (String value : titles) &#123;</span><br><span class="line">            <span class="comment">// 创建单元格</span></span><br><span class="line">            <span class="type">XSSFCell</span> <span class="variable">cell</span> <span class="operator">=</span> row.createCell(columnIndex++);</span><br><span class="line">            cell.setCellValue(value);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//写入每行的数据</span></span><br><span class="line">        <span class="keyword">if</span> (list != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">rowNum</span> <span class="operator">=</span> <span class="number">1</span>; <span class="comment">//从第一行开始</span></span><br><span class="line">            <span class="keyword">for</span> (DataHistory dataHistory : list) &#123;</span><br><span class="line">                columnIndex = <span class="number">0</span>; <span class="comment">//列数重置为0</span></span><br><span class="line">                <span class="type">XSSFRow</span> <span class="variable">newRow</span> <span class="operator">=</span> sheet.createRow(rowNum++);</span><br><span class="line">                <span class="comment">//创建线程池</span></span><br><span class="line">                <span class="type">ExecutorService</span> <span class="variable">es</span> <span class="operator">=</span> Executors.newCachedThreadPool();</span><br><span class="line">                </span><br><span class="line">                <span class="type">CountDownLatch</span> <span class="variable">doneSignal</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(<span class="number">5</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">for</span> (String value : titles) &#123;</span><br><span class="line">                        <span class="type">XSSFCell</span> <span class="variable">cell</span> <span class="operator">=</span> newRow.createCell(columnIndex++);</span><br><span class="line">                        es.submit(</span><br><span class="line">                                <span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">                                    <span class="meta">@Override</span></span><br><span class="line">                                    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                                        cell.setCellValue(getValues(value, dataHistory));</span><br><span class="line">                                        doneSignal.countDown();</span><br><span class="line">                                    &#125;</span><br><span class="line">                                &#125;</span><br><span class="line">                        );</span><br><span class="line"></span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//使用CountDownLatch的await方法，等待所有线程完成sheet操作</span></span><br><span class="line">                    doneSignal.await();</span><br><span class="line">                    es.shutdown();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> workbook;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="CountDownLatch"><a href="#CountDownLatch" class="headerlink" title="CountDownLatch"></a><code>CountDownLatch</code></h4><p>是一个同步工具类，用来协调多个线程之间的同步，能够使一个线程在等待另外一些线程完成各自工作之后，再继续执行。使用一个计数器进行实现。计数器初始值为线程的数量。当每一个线程完成自己任务后，计数器的值就会减一。当计数器的值为0时，表示所有的线程都已经完成一些任务，然后在CountDownLatch上等待的线程就可以恢复执行接下来的任务</p><h4 id="线程池实现方式"><a href="#线程池实现方式" class="headerlink" title="线程池实现方式"></a>线程池实现方式</h4><h5 id="Executor"><a href="#Executor" class="headerlink" title="Executor"></a>Executor</h5><p>Executor 接口是线程池框架中最基础的部分，定义了一个 <code>void execute(Runnable command)</code> 方法，代表提交一个任务，由线程池来执行这个任务。</p><h5 id="ExecutorService"><a href="#ExecutorService" class="headerlink" title="ExecutorService"></a>ExecutorService</h5><p>Executor 下有一个重要子接口 ExecutorService，其中定义了一些可以操作线程池的方法：</p><p>public interface ExecutorService extends Executor {</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 关闭线程池，已经提交的任务继续执行，不再接受新的任务</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">shutdown</span><span class="params">()</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 尝试停止正在执行的任务，返回等待执行的任务列表。因为停止正在执行的线程使用 Thread.interrupt() 方法， 所以不保证能够完全停止</span></span><br><span class="line">List&lt;Runnable&gt; <span class="title function_">shutdownNow</span><span class="params">()</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 当前线程池是否已经关闭</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">isShutdown</span><span class="params">()</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 如果关闭后，所有任务都已经完成，则返回true</span></span><br><span class="line"><span class="comment">// 并且只有先调用 shutdown 或 shutdownNow 才会返回 true</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">isTerminated</span><span class="params">()</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 等待请求关闭线程池后，所有的任务完成或者等待超时</span></span><br><span class="line"><span class="comment">// 如果所有的任务都已经完成了，则返回 true，超时的话返回 false</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">awaitTermination</span><span class="params">(<span class="type">long</span> timeout, TimeUnit unit)</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 提交一个 Callable 任务，并返回一个表示任务的挂起结果的 Future，之后可以通过 Future 的 get() 方法来获取任务成功完成后返回的结果</span></span><br><span class="line">&lt;T&gt; Future <span class="title function_">submit</span><span class="params">(Callable&lt;T&gt; task)</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 提交一个 Runnable 任务，因为 Runable 的 run() 方法没有返回值，第二个参数会放到 Future 中作为返回值</span></span><br><span class="line">&lt;T&gt; Future <span class="title function_">submit</span><span class="params">(Runnalbe task, T result)</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 提交一个 Runable 任务，因为没有指定返回值，所以之后在 Future 中获取的返回值为 null</span></span><br><span class="line">Future&lt;?&gt; submit(Runnable task);</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 执行所有任务，返回 Future 类型的集合</span></span><br><span class="line">&lt;T&gt; List&lt;Future&lt;T&gt;&gt; <span class="title function_">invokeAll</span><span class="params">(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks)</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 执行所有任务，但设置了超时时间</span></span><br><span class="line">&lt;T&gt; List&lt;Future&lt;T&gt;&gt; <span class="title function_">invokeAll</span><span class="params">(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks, <span class="type">long</span> timeout, TimeUnit unit)</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 执行所有的任务，只要其中一个执行结束，就可以返回那个任务的结果</span></span><br><span class="line">&lt;T&gt; invokeAny(Collection&lt;? <span class="keyword">extends</span> <span class="title class_">Callable</span>&lt;T&gt;&gt; tasks);</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 同上一个方法，设置了超时时间</span></span><br><span class="line">&lt;T&gt; T <span class="title function_">invokeAny</span><span class="params">(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks, <span class="type">long</span> timeout, TimeUnit unit)</span>;</span><br></pre></td></tr></table></figure><h5 id="ThreadPoolExecutor"><a href="#ThreadPoolExecutor" class="headerlink" title="ThreadPoolExecutor"></a>ThreadPoolExecutor</h5><p> JDK 中线程池的默认实现，实现了线程池中的基本方法，可以直接使用，或者基本它扩展，来实现我们需要的功能,下面这个是 <code>ThreadPoolExecutor</code> 的核心构造函数，其他的构造函数最终都会走到该构造方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ThreadPoolExecutor</span><span class="params">(<span class="type">int</span> corePoolSize,</span></span><br><span class="line"><span class="params">                         <span class="type">int</span> maximumPoolSize,</span></span><br><span class="line"><span class="params">                         <span class="type">long</span> keepAliveTime,</span></span><br><span class="line"><span class="params">                         TimeUnit unit,</span></span><br><span class="line"><span class="params">                         BlockingQueue&lt;Runnable&gt; workQueue,</span></span><br><span class="line"><span class="params">                         ThreadFactory threadFactory,</span></span><br><span class="line"><span class="params">                         RejectExecutionHandler handler</span></span><br></pre></td></tr></table></figure><h6 id="参数说明"><a href="#参数说明" class="headerlink" title="参数说明"></a>参数说明</h6><ul><li><code>corePoolSize</code> 是线程池中的<strong>核心线程数</strong>，<code>maxinumPoolSize</code> 是线程池中允许的<strong>最大线程数</strong>，当当前正在运行的线程数小于 <code>corePoolSize</code> 值，新提交任务时，会创建一个新的线程来执行，即使有空闲的线程；当当前正在运行的线程数大于 <code>corePoolSize</code> 值，且小于<code>maximumPoolSize</code> 值，新任务会提交到等待队列中，直到<strong>等待队列</strong>满了，才会创建新的线程执行任务。</li><li><code>keepAliveTime</code>线程允许的最大空闲时间。且默认情况下，只会在超时后，销毁非核心线程。也可以通过调用 <code>allowCoreThreadTimeOut(true)</code> 方法，来将这种策略应用于核心线程</li><li><code>unit</code>,<code>keepAliveTime</code> 的时间单位</li><li><code>workQueue</code> 是用来保存等待被执行任务的阻塞队列，通常和线程池的大小对应调整。</li><li><code>threadFactory</code>创建线程的工厂类，用来创建新线程</li><li><code>handler</code>线程池的拒绝策略,当线程池处于关闭状态，或者阻塞队列满了，而且线程数量已经达到了 <code>maximumPoolSize</code>，再提交任务时，就会执行当前指定的策略</li></ul>]]></content>
      
      
      <categories>
          
          <category> 调优记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
